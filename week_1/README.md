# Bench / Before-After Notes (Day1)
| 항목 | Before (Baseline) | After (Strategy) |
|---|------------------:|-----------------:|
| 조건문 수 |                3개 |               0개 |
| 신규 정책 추가시 수정 파일 수 |                1개 |               0개 |
간단 메모:
- 선택 이유:
    - BigDecimal : 소숫점 계산을 할 때, 발생하는 부정확도를 잡아준다. 계산을 진행할 때 두 수의 scale을 맞춘 뒤 unscaledValue 정수끼리 더하고, 스케일 유지
      즉, 내부적으로 scale과 unscaledValue를 저장해서 정밀도를 잃지 않는다.

    - Strategy vs If : 직접 ThresholdRateDiscount를 추가해보며 인터페이스를 구현해서 client에서 주입하는 경우 기존 Calculator 코드에 대한 수정이 필요하지 않다.
      하지만, BaselineDiscountCalculator의 경우 새로운 가격 할인 정책이 생성되면 if(mode == Mode.Threshold){...}를 추가해야하고 enum도 계속 수정해야한다.
      이를 바탕으로, 결론을 내릴 수 있는 것은 전략 패턴을 사용하면 SOLID의 확장에는 열려있고 수정에는 닫혀있는 개방 폐쇄 원칙을 지킬 수 있다.

- 관찰된 부작용/Trade-off:
    - BigDecimal : 불변 객체라 연산마다 새 객체를 생성하고, 스케일이 다를 경우 스케일을 맞추는데 들어가는 비용, 반올림,정밀도 규칙때문에 고부하 시스템에서는 병목지점이 될 수 있다. 즉, 정확성과 규칙성을 얻는대신 속도를 포기하는 것
    - 전략(규칙) 하나 늘 때마다 클래스 수 증가(파일 관리/이름 피로), originalPrice 검증·라운딩 같은 공통 로직 중


---

## 언제 사용해야할까?

1. 서로 대체 가능한 ‘행동’이 최소 2개 이상 존재한다.
2. 그 행동을 선택/교체해야 할 합리적 이유가 있다(규칙 변화, 환경/입력/구성에 따라).
3. 새로운 행동 추가 시 클라이언트 수정 없이 확장된다
4. 선택 로직이 런타임 구성(팩토리/DI/설정/상황 값) 으로 이어질 여지가 있다.

## 정리

서로 대체 가능한 행동들을 한 그룹으로 정의하고 캡슐화해,
클라이언트가 알고리즘을 교체 가능하도록 만든다.